\newcommand{\actionx}{\kw{ACTIONX}}
\chapter{Programming in the deck: \actionx}
\label{actionx}
The \actionx{} keyword is the most direct way to \emph{program} in the deck. The
\actionx{} functionality consist of the \actionx{} keyword itself, with some
metadata and a condition and then a list of keywords which are injected into the
in-memory representation of the \kw{SCHEDULE} section at the point in time where
the condition evaluates to true. The \actionx{} statement is evaluated at the
end of every timestep, and if it evaluates to true the new keywords should take
effect immediately.

\section{Structure of the \actionx{} keyword}
The \actionx{} keyword itself consist of multiple records. The first record is
metadata with the name of action, the number of times the action can be
triggered and the minimum time elapsed before an action is eligible for a second
run. The subsequent records are \emph{conditions}, all the conditions are of the
same form
\begin{code}
  lhs comparison rhs
\end{code}
The \inlinecode{lhs} is a field, well or group quantity, in addition you can
use time variables \kw{DAY}, \kw{MNTH} and \kw{YEAR} as left hand
side\footnote{\eclipse{} supports a wider list of summary variables like region,
block and aquifer quantities on the left hand side.}. As with the \udq{}
variables the well and group variables are \emph{sets}, and the evaluation
status is maintained individually for each well and group.

The comparison is one of the ordinary mathematical comparison operators
\inlinecode{>,<,=,!=, <=} and \inlinecode{>=}. Numerical comparisons are done
with the corresponding plain C++ operators, this is in contrast to the \udq{}
implementation where an epsilon defined in \kw{UDQPARAMS} is used in floating
point comparisons.

The \inlinecode{rhs} is a numerical scalar, or a field, well or group quantity.
If your \inlinecode{rhs} is a well or group quantity the \inlinecode{lhs} and
\inlinecode{rhs} must be of the same type. If you use the symbol \kw{MNTH} as
\inlinecode{lhs} you can compare with named months, i.e. the following will
trigger on leap days
\begin{deck}
ACTIONX
  LEAP 1000 /
  MNTH=FEB AND /
  DAY=29 /
/
...
...
ENDACTIO
\end{deck}
When there is a well/group quantity as \inlinecode{lhs} the evaluation status is
maintained individually for each well/group. The complete condition evaluates to
true if \emph{any} of the wells/groups satisfy the condition, in the case of
wells the matching wells can subsequently be accessed with wellname '?' in the
\kw{ACTIONX} keywords, this is a quite common pattern to e.g. close the well
with highest watercut.

If there are more conditions they must be joined with a trailing \kw{AND} or
\kw{OR}, furthermore conditions can be grouped with paranthesis. The quantities
in an \actionx{} expression must be ``quite simple'', for more advanced
expressions the natural way is to first define a \udq{} and then use the
\udq{symbol} in the \actionx{}, this is illustrated in section \ref{uda}. When
one multiple conditions involving the same well set are evaluated, the list of
matching wells available in '?' will only contain the wells from the final
condition, i.e. for
\begin{code}
 WWCT = {"OP1": 0.25, "OP2": 0.50, "OP3": 0.75}
\end{code}
and the action
\begin{deck}
ACTIONX
  WWCT /
  WWCT > 0.33 AND /
  WWCT < 0.66 /
/
...
ENDACTIO
\end{deck}
the set of wells available for further use in '?' are \emph{all} the wells
matching the condition \inlinecode{WWCT < 0.66} i.e. OP1 and OP2 and \emph{not}
the wells matching the combined expression \inlinecode{0.33 < WWCT < 0.66} which
would only be OP2. In order select wells in a range as attempted here you will
have to create an indicator variable with \udq{} first and then select based on
that indicator - e.g. something like
\begin{deck}
UDQ
  DEFINE WUCTR (WWCT < 0.66) * (WWCT > 0.33) /
/

ACTIONX
  WUCTR /
  WUCTR = 1 /
/

...

ENDACTIO
\end{deck}



\section{Forward references of wells and groups}
When a well or group is defined as an \actionx{} keyword and then
unconditionally refered to in the deck we get a problem at the first pass
through the Schedule section:

\begin{deck}
ACTIONX
   'ACTION' /
   WWCT OPX  > 0.75 /
/

WELSPECS
  'W1'  'OP'  1 1 3.33  'OIL' 7*/
/

ENDACTIO

TSTEP
  10*30 /

WCONPROD
 'W1'      'OPEN'      'ORAT'      0.000      0.000      0.000  5* /
/

TSTEP
  10*30 /

\end{deck}

In \flow{} this is ``solved'' in the following way:
\begin{enumerate}
\item At first pass we inspect the keywords inside the \actionx{} block and if
  we discover \kw{WELSPECS} we store the name of the well which will be defined
  at a later stage through \actionx{}.
\item When we parse further on as part of the first pass and said well is
  referenced e.g. in a \kw{WCONPROD} we verify that the well will eventually
  appear via \actionx{} - we issue a warning and ignore the \kw{WCONPROD}
  keyword\footnote{If the well is not registered as ``will appear through
  \actionx{} there will be a runtime error with unknown well name when parsing
  \kw{WCONPROD}.}.
\item When the \actionx{} evaluates to true the well will be properly defined,
  and when reiterating over the Schedule keywords the \kw{WCONPROD} keyword will
  now be properly internalized.

  If the \actionx{} never evaluates to true the \kw{WCONPROD} keyword will
  silently be ignored. This is probably not what the user wanted, but it is also
  not a bug?
\end{enumerate}
It should be mentioned that the functionality with forward referencing of well
names is quite new, there might very well be well keywords in the \kw{SCHEDULE}
section where the implementation is not yet prepared for this. Furthermore the
forward referencing is not at all implemented for groups. The releavnt data
structure is the member \inlinecode{Action::WGNames action\_wgnames} in the
\inlinecode{Schedule} class.


\section{To enable a new keyword for \actionx}
The keywords must be explicitly enabled to be usable in an \actionx{} block, and
enabling a new keyword requires recompiling \flow{}. The hardcoded list of
keywords avaiailable as \actionx{} keywords are listed in the static method
\inlinecode{ActionX::valid\_keyword()} in
\path{opm/input/eclipse/Schedule/Action/ActionX.cpp}. In principle it should
just be to add the keyword to the \inlinecode{ActionX::valid\_keyword()} method
and rebuild \flow{}, but experience has unfortunately shown that problems of
various kinds have had a tendency to pop up when new keywords are tried out as
\actionx{} keywords.

\section{Implemenation details}
The \actionx{} implementation is located in
\path{opm/input/eclipse/Schedule/Action} and all the classes are in namespace
\inlinecode{Action::}. As with the \udq{} the input parser needs some special
case to handle '/' and '*' as division operator and multiplier respectively, but
that is the only code shared between the \udq{} and the \actionx{}
implementation\footnote{It might be possible to share more code between the two,
in particular both have an internal recursive descent parser, but both \udq{}
and \actionx{} have so much ``personality'' that at least initially separate
implementations was the simplest.}.

\subsection*{The \inlinecode{Schedule} implementation}
\flow{} internalizes all keywords from the input deck and passes datastructures
to the simulator, whereas the impression is that \eclipse{} works more like a
reservoir model interepreter, executing one keywords at a time. Mostly the
\flow{} approach has worked out well, however for the \actionx{} functionality
the difference in execution model is quite acute, and the needs of \actionx{}
has had quite strong influence on the final Schedule implementation. Although
not required for use of \actionx{} it is valuable to understand how the
\actionx{} functionality has influenced the design of the Schedule class, that
way you will hopefully better understand problems or bugs which might arise in
the future.

At the very first pass the \kw{SCHEDULE} section is split in \emph{blocks}, with
one block for each report step. The blocks are implemented with the class
\inlinecode{ScheduleBlock}. Each block has a starting time and a list of
keywords, the keywords are maintained in the input format
\inlinecode{DeckKeyword}. Then the entire \kw{SCHEDULE} section is internalized
in the class \inlinecode{ScheduleDeck} which essentially contains a list of
\inlinecode{ScheduleBlock} instances. Consider the \kw{SCHEDULE} section
\begin{deck}
START
  1 'JAN' 2020 /

...
...

SCHEDULE

WELSPECS
	'PROD'	'G1'	10	10	8400	'OIL' /
	'INJ'	'G1'	1	1	8335	'GAS' /
/

COMPDAT
	'PROD'	10	10	3	3	'OPEN'	1*	1*	0.5 /
	'INJ'	1	1	1	1	'OPEN'	1*	1*	0.5 /
/

-- End of block 0

DATES
   1 'FEB' 2020 /
/

WCONPROD
	'PROD' 'OPEN' 'ORAT' 20000 4* 1000 /
/

WCONINJE
	'INJ'	'GAS'	'OPEN'	'RATE'	100000 1* 9014 /
/

-- End of block 1

DATES
  1 'MAR' 2020 /
/

-- End of block 2
END

\end{deck}

When this is internalized we get a \inlinecode{ScheduleDeck} instance with three
\inlinecode{ScheduleBlock} instances:

\begin{code}
ScheduleDeck sched_deck = [
  ScheduleBlock {
    start = "2020-01-01",
    keywords = ["WELSPECS","COMPDAT"]
  },
  ScheduleBlock {
    start = "2020-02-01",
    keywords = ["WCONPROD","WCONINJE"]
  },
  ScheduleBlock {
    start = "2020-03-01",
    keywords = []
  }
]
\end{code}

The \inlinecode{Schedule} class has a \inlinecode{ScheduleDeck} member. The
processed content of the \inlinecode{ScheduleClass} is managed in vector of
\inlinecode{ScheduleState} instances, where one \inlinecode{ScheduleState}
represents the complete dynamic input state at a particular report step. The
processed \kw{SCHEDULE} code is created with the method
\inlinecode{Schedule::iterateScheduleSection()}. The important point is that the
\inlinecode{Schedule::iterateScheduleSection()} method is idempotent - it can be
called repeatedly.

With this in mind the essence of how \actionx{} keywords are injected into the
\inlinecode{Schedule} class is just to append the \actionx{} keywords in the
\inlinecode{ScheduleBlock} instance corresponding to the current report step and
then rerun the \inlinecode{Schedule::iterateScheduleSection} from this report
step.

\subsection*{\actionx{} input}
While parsing the \kw{SCHEDULE} section the \actionx{} keywords are somewhat
special cased - the keywords are not internalized but rather tucked away for
future injection. The keywords in the \actionx{} are parsed and stored in a
class \inlinecode{Action::ActionX} and all of these instances are in a vector
\inlinecode{Action::Actions}.


\section{Interaction with the simulator}

\begin{enumerate}
\item WELPI
\item General changes in well status
\item Changes in geo properties
\end{enumerate}

The actionx implementation is in the module opm-common, whereas when the
simulation is proceeding it is the simulator code which is clearly in control.
If an action has evaluated to true and new keywords should be injected in the
Schedule object and thereby the complete simulator state is updated. This is
complex, and many of the bugs in \actionx{} functionality have been in the
interaction between the simulator and opm-common, in particular when an action
has evaluated to true.

Another challenge is that the simulator code makes \emph{copies} of many of the
objects like wells and connections from the \inlinecode{Schedule} class. Some of
the interaction between the simulator and the input layer could probably be
simplified if the simulator would call the \inlinecode{Schedule} object when
e.g. a well or connection is needed, instead of storing references or copies to
the \inlinecode{Schedule} objects internally.

