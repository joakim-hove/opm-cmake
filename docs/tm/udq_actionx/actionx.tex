\newcommand{\actionx}{\kw{ACTIONX}}
\chapter{Programming in the deck: \actionx}
\label{actionx}
The \actionx{} keyword is the most direct way to \emph{program} in the deck. The
\actionx{} functionality consist of the \actionx{} keyword itself, with some
metadata and a condition and then a list of keywords which are injected into
Schedule section at the point in time where the condition evaluates to true.

\begin{deck}
ACTIONX
INJECTION 10 0 /
WBHP P1 < 200.0 /
/

WELOPEN
  'WI1' 'OPEN' 5* /
/

ENDACTIO
\end{deck}
The \actionx{} statement is evaluated at the end of every timestep, and if it
evaluates to true the new keywords should take effect immediately.



\section{Interaction with the simulator}

\begin{enumerate}
\item WELPI
\item General changes in well status
\item Changes in geo properties
\end{enumerate}

The actionx implementation is in the module opm-common, whereas when the
simulation is proceeding it is the simulator code which is clearly in control.
If an action has evaluated to true and new keyword must be injected in the
Schedule object and thereby the complete simulator state is updated. This is
complex, and many of the bugs in \actionx{} functionality have been in the
interaction between the simulator and opm-common, in particular when an action
has evaluated to true.



\section{Forward references of wells and groups}
When a well or group is defined as an \actionx{} keyword and then
unconditionally refered to in the deck we get a problem at the first pass
through the Schedule section:

\begin{deck}
ACTIONX
   'ACTION' /
   WWCT OPX  > 0.75 /
/

WELSPECS
  'W1'  'OP'  1 1 3.33  'OIL' 7*/
/

ENDACTIO

TSTEP
  10*30 /

WCONPROD
 'W1'      'OPEN'      'ORAT'      0.000      0.000      0.000  5* /
/

TSTEP
  10*30 /

\end{deck}

In \flow{} this is ``solved'' in the following way:
\begin{enumerate}
\item At first pass we inspect the keywords inside the \actionx{} block and if
  we discover \kw{WELSPECS} we store the name of the well which will be defined
  at a later stage through \actionx{}.
\item When we parse further on as part of the first pass and said well is
  referenced e.g. in a \kw{WCONPROD} we verify that the well will eventually
  appear via \actionx{} - we issue a warning and ignore the \kw{WCONPROD}
  keyword\footnote{If the well is not registered as ``will appear through
  \actionx{} there will be a runtime error with unknown well name when parsing
  \kw{WCONPROD}.}.
\item When the \actionx{} evaluates to true the well will be properly defined,
  and when reiterating over the Schedule keywords the \kw{WCONPROD} keyword will
  now be properly internalized.

  If the \actionx{} never evaluates to true the \kw{WCONPROD} keyword will
  silently be ignored. This is probably not what the user wanted, but it is also
  not a bug?
\end{enumerate}

\section{Implemenation details}
The \actionx{} implementation is located in
\path{opm/input/eclipse/Schedule/Action} and all the classes are in namespace
\inlinecode{Action::}. As with the \udq{} the input parser needs some special
case to handle '/' and '*' as division operator and multiplier respectively, but
that is the only code shared between the \udq{} and the \actionx{}
implementation\footnote{It might be possible to share more code between the two,
in particular both have an internal recursive descent parser, but both \udq{}
and \actionx{} have so much ``personality'' that at least initially separate
implementations was the simplest.}.

\subsection*{The \inlinecode{Schedule} implementation}
\flow{} internalizes all keywords from the input deck and passes datastructures
to the simulator, whereas the impression is that \eclipse{} works more like an
interepreter executing the keywords one at a time. Mostly the \flow{} approach
of internalizing everything before simulation actually starts has worked out
well, however for the \actionx{} functionality the difference in execution model
is quite acute, and the needs of \actionx{} has had quite strong influence on
the final Schedule implementation. Although not required for use of \actionx{}
it is valuable to understand how the \actionx{} functionality has influenced the
design of the Schedule class, that way you will hopefully better understand
problems or bugs which might arise in the future.

At the very first pass the \kw{SCHEDULE} section is split in \emph{blocks}, with
one blocks for each report step. The blocks are implemented with the class
\inlinecode{ScheduleBlock}. Each block has a starting time and a list of
keywords, the keywords are maintained in the input format
\inlinecode{DeckKeyword}. Then the entire \kw{SCHEDULE} section is internalized
in the class \inlinecode{ScheduleDeck} which essentially contains a list of
\inlinecode{ScheduleBlock} instances. Consider the \kw{SCHEDULE} section
\begin{deck}
START
  1 'JAN' 2020 /

...
...

SCHEDULE

WELSPECS
	'PROD'	'G1'	10	10	8400	'OIL' /
	'INJ'	'G1'	1	1	8335	'GAS' /
/

COMPDAT
	'PROD'	10	10	3	3	'OPEN'	1*	1*	0.5 /
	'INJ'	1	1	1	1	'OPEN'	1*	1*	0.5 /
/

DATES
   1 'FEB' 2020 /
/

WCONPROD
	'PROD' 'OPEN' 'ORAT' 20000 4* 1000 /
/

WCONINJE
	'INJ'	'GAS'	'OPEN'	'RATE'	100000 1* 9014 /
/

DATES
  1 'MAR' 2020 /
/

END

\end{deck}


\section{To enable a new keyword for \actionx}
The keywords must be explicitly enabled to be usable in an \actionx{} block, and
enabling a new keyword requires recompiling \flow{}. The hardcoded list of
keywords avaiailable as \actionx{} keywords are listed in the static method
\inlinecode{ActionX::valid\_keyword()} in
\path{opm/input/eclipse/Schedule/Action/ActionX.cpp}. In principle it should
just be to add the keyword to the \inlinecode{ActionX::valid\_keyword()} method
and rebuild \flow{}, but experience has unfortunately shown that problems of
various kinds have had a tendency to pop up when new keywords are tried out as
\actionx{} keywords.


